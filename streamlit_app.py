import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import time
import random

# Define a list of possible vulnerabilities and their severities
vuln_types = ["SQL Injection", "XSS", "Open Redirect", "Directory Traversal", "Command Injection", 
              "Cross-Site Request Forgery", "Path Traversal", "Remote Code Execution"]
severity_levels = ["Low", "Medium", "High", "Critical"]

# Randomly generate a list of vulnerabilities and severities for the scan result
def generate_vulnerabilities():
    return [{"type": random.choice(vuln_types), "severity": random.choice(severity_levels)} 
            for _ in range(random.randint(5, 15))]

# Simulate Vulnerability Data (this will now be dynamically generated)
vuln_data = generate_vulnerabilities()

# Convert to DataFrame
vuln_df = pd.DataFrame(vuln_data)

# Dashboard Layout
st.set_page_config(page_title="Vulnerability Scanner Dashboard", layout="wide")
st.title("Website Vulnerability Scan Report")

# Input URL for scan (Just a mock field here, not functional)
url = st.text_input("Enter Website URL to Scan", "https://crossroadswithshazinhijazy.com/")

# Simulate scan progress
with st.spinner("Performing scan..."):
    time.sleep(2)  # Simulate scan delay (replace with actual scan process)

# Display Summary Information
st.subheader(f"Scan Report for {url}")
scan_duration = round(random.uniform(2.5, 5.5), 2)  # Randomized scan duration
st.write(f"Scan Duration: {scan_duration} seconds")
st.write(f"Total Vulnerabilities Detected: {len(vuln_df)}")

# Pie chart of Severity Levels
severity_counts = vuln_df['severity'].value_counts()
fig, ax = plt.subplots()
ax.pie(severity_counts, labels=severity_counts.index, autopct='%1.1f%%', startangle=90)
ax.axis('equal')  # Equal aspect ratio ensures pie is drawn as a circle.
st.subheader("Vulnerability Severity Breakdown")
st.pyplot(fig)

# Bar chart of Vulnerability Types
type_counts = vuln_df['type'].value_counts()
fig2, ax2 = plt.subplots(figsize=(8, 5))  # Adjust figure size
sns.barplot(x=type_counts.index, y=type_counts.values, ax=ax2)
ax2.set_title('Vulnerabilities by Type')
ax2.set_xlabel('Vulnerability Type')
ax2.set_ylabel('Count')

# Rotate x-axis labels for better readability
plt.xticks(rotation=45, ha='right')

# Ensure labels are not clipped
plt.tight_layout()

st.pyplot(fig2)

# Display Vulnerabilities in a Table
st.subheader("Detailed Vulnerability Information")
st.dataframe(vuln_df)

# Remediation Suggestions based on vulnerability type
remediation_dict = {
    "SQL Injection": "Ensure proper input validation, use prepared statements, and parameterized queries.",
    "XSS": "Use input sanitization and output encoding. Implement Content Security Policy (CSP).",
    "Open Redirect": "Validate URLs to ensure they lead to trusted locations.",
    "Directory Traversal": "Ensure proper validation of user input for file paths.",
    "Command Injection": "Ensure all user inputs are sanitized and validated before being passed to system commands.",
    "Cross-Site Request Forgery": "Use anti-CSRF tokens, SameSite cookies, and user-specific headers.",
    "Path Traversal": "Implement input validation to prevent file path manipulation.",
    "Remote Code Execution": "Sanitize user inputs, avoid eval() or exec(), and ensure safe execution contexts."
}

st.subheader("Remediation Suggestions")
for index, row in vuln_df.iterrows():
    vuln_type = row['type']
    st.write(f"**{vuln_type}**: Recommended Action: {remediation_dict.get(vuln_type, 'No recommendation available for this vulnerability type.')}")
    
# Additional dynamic information - Example of fixing specific vulnerabilities
if "Remote Code Execution" in vuln_df['type'].values:
    st.markdown("### Critical: Remote Code Execution detected! Immediate remediation is required.")
    st.markdown("**Suggested Immediate Action**: Restrict user input, avoid unsanitized system calls.")
elif "SQL Injection" in vuln_df['type'].values:
    st.markdown("### High: SQL Injection detected!")
    st.markdown("**Suggested Immediate Action**: Implement prepared statements to prevent malicious queries.")

# Conclusion
st.markdown("**End of Scan**: Review the vulnerabilities and apply necessary fixes.")